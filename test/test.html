<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hand Gesture Recognition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            display: flex; /* Added display:flex to center the content */
            justify-content: center; 
            align-items: center; 
            height: 100vh; /* Full viewport height */
            margin: 0;
            background-color: #f0f0f0; /* Optional: background color for better visibility */
        }
        .output_canvas { 
            border: 1px solid black; 
            max-width: 100%;
            height: auto;
            transform: rotate(0deg); /* Default rotation */
        }
        #fingerCount { 
            font-size: 24px; 
            color: black; 
            margin-top: 10px; 
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="container">
        <div style="display: none;">
            <video class="input_video" playsinline></video>
        </div>
        <canvas class="output_canvas"></canvas>
        <div id="fingerCount">Fingers Raised: 0</div>
    </div>

    <script type="module">
        // Function to determine device type based on screen width
        function isMobileDevice() {
            return window.innerWidth <= 430; // Adjust the breakpoint as needed
        }

        // Set canvas and camera dimensions based on device type
        let canvasWidth, canvasHeight;
        let mobileDevice = isMobileDevice();

        function setCanvasDimensions() {
            mobileDevice = isMobileDevice();
            if (mobileDevice) {
                canvasWidth = 720; // Portrait width
                canvasHeight = 1080; // Portrait height (swapped for rotation)
            } else {
                canvasWidth = 1080;
                canvasHeight = 720;
            }

            // Update the canvas element
            const canvasElement = document.getElementsByClassName('output_canvas')[0];
            canvasElement.width = canvasWidth;
            canvasElement.height = canvasHeight;

            // Apply CSS rotation for portrait mode
            if (mobileDevice) {
                canvasElement.style.transform = 'rotate(90deg)';
                canvasElement.style.transformOrigin = 'center center';
            } else {
                canvasElement.style.transform = 'rotate(0deg)';
            }
        }
        // Initial setup
        setCanvasDimensions();

        // Update canvas dimensions on window resize
        window.addEventListener('resize', () => {
            setCanvasDimensions();
        });

        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const fingerCountDisplay = document.getElementById('fingerCount');

        function countFingers(lmlist) {
            let fingerCount = 0;
            const tipIds = [4, 8, 12, 16, 20]; // Thumb, Index, Middle, Ring, Pinky

            // Check the thumb
            const isThumbRaised = lmlist[tipIds[0]][1] < lmlist[tipIds[0] - 1][1]; // Thumb up if tip is above the base
            if (isThumbRaised) {
                fingerCount += 1;
            }

            // Check the other fingers
            for (let i = 1; i < tipIds.length; i++) {
                const isFingerRaised = lmlist[tipIds[i]][2] < lmlist[tipIds[i] - 2][2]; // Tip above second joint
                if (isFingerRaised) {
                    fingerCount += 1;
                }
            }

            return fingerCount;
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Apply rotation if in portrait mode
            if (mobileDevice) {
                canvasCtx.translate(canvasWidth / 2, canvasHeight / 2);
                canvasCtx.rotate(Math.PI / 2); // 90 degrees
                canvasCtx.translate(-canvasWidth / 2, -canvasHeight / 2);
            }

            // Draw the video frame
            canvasCtx.drawImage(results.image, 0, 0, canvasWidth, canvasHeight);

            for (const landmarks of results.multiHandLandmarks) {
                const lmlist = [];
                for (let id = 0; id < 21; id++) {
                    let x = landmarks[id].x * canvasElement.width;
                    let y = landmarks[id].y * canvasElement.height;

                    // Adjust landmarks for portrait orientation
                    if (mobileDevice) {
                        // Rotate the coordinates for portrait
                        const rotatedX = y;
                        const rotatedY = canvasWidth - x; // Adjust y after rotation
                        x = rotatedX;
                        y = rotatedY;
                    }

                    lmlist.push([id, Math.round(x), Math.round(y)]);
                }

                if (lmlist.length === 21) {
                    const fingerCount = countFingers(lmlist);
                    fingerCountDisplay.innerText = `Fingers Raised: ${fingerCount}`;
                    console.log(fingerCount);
                }

                // Draw landmarks and connections
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });
            }

            canvasCtx.restore();
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.3
        });
        hands.onResults(onResults);

        let camera;

        function startCamera() {
            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: mobileDevice ? canvasHeight : canvasWidth,
                height: mobileDevice ? canvasWidth : canvasHeight,
                facingMode: 'user', // Use front camera if available
            });
            camera.start();
        }

        startCamera();
    </script>
</body>
</html>
