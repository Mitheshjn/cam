<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Hand Gesture Recognition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { 
            display: flex;
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
        }
        .output_canvas { 
            border: 1px solid black; 
            max-width: 100%;
            height: auto;
        }
        #fingerCount { 
            font-size: 24px; 
            color: black; 
            margin-top: 10px; 
        }
    </style>
</head>

<body>
    <div class="container">
        <div style="display: none;">
            <video class="input_video" playsinline></video>
        </div>
        <canvas class="output_canvas"></canvas>
        <div id="fingerCount">Fingers Raised: 0</div>
    </div>

    <script type="module">
        // Function to determine device type based on screen width
        function isMobileDevice() {
            return window.innerWidth <= 430; // Adjust the breakpoint as needed
        }

        // Set canvas and camera dimensions based on device type
        let canvasWidth, canvasHeight;
        let mobileDevice = isMobileDevice();

        function setCanvasDimensions() {
            mobileDevice = isMobileDevice();
            if (mobileDevice) {
                canvasWidth = window.innerWidth; // Set canvas width to device width
                canvasHeight = canvasWidth * 16 / 9; // Maintain 16:9 aspect ratio for portrait mode
            } else {
                canvasWidth = 1080;
                canvasHeight = 720;  // Landscape on desktop
            }

            const canvasElement = document.getElementsByClassName('output_canvas')[0];
            canvasElement.width = canvasWidth;
            canvasElement.height = canvasHeight;
        }

        // Initial setup
        setCanvasDimensions();

        // Handle window resize with debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                setCanvasDimensions();
                if (camera) {
                    camera.stop();
                    camera.width = canvasWidth;
                    camera.height = canvasHeight;
                    camera.start();
                }
            }, 500); // 500ms debounce
        });

        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const fingerCountDisplay = document.getElementById('fingerCount');

        // Crop video to fit fully within the canvas without stretching
        function cropAndFitVideo(video, canvasWidth, canvasHeight) {
            const videoAspectRatio = video.videoWidth / video.videoHeight;
            const canvasAspectRatio = canvasWidth / canvasHeight;

            let drawWidth, drawHeight, offsetX, offsetY;

            if (canvasAspectRatio > videoAspectRatio) {
                // Video is taller than canvas, fit by height and crop width
                drawHeight = canvasHeight;
                drawWidth = video.videoWidth * (canvasHeight / video.videoHeight);
                offsetX = (canvasWidth - drawWidth) / 2; // Center horizontally
                offsetY = 0;
            } else {
                // Video is wider than canvas, fit by width and crop height
                drawWidth = canvasWidth;
                drawHeight = video.videoHeight * (canvasWidth / video.videoWidth);
                offsetX = 0;
                offsetY = (canvasHeight - drawHeight) / 2; // Center vertically
            }

            return { drawWidth, drawHeight, offsetX, offsetY };
        }

        function countFingers(lmlist) {
            let fingerCount = 0;
            const tipIds = [4, 8, 12, 16, 20]; // Thumb, Index, Middle, Ring, Pinky

            // Check thumb separately for left/right hand orientation
            let isRightHand = lmlist[12][1] > lmlist[20][1]; // Determine if it's a right hand

            // Check thumb based on hand orientation
            const isThumbRaised = isRightHand
                ? lmlist[tipIds[0]][1] > lmlist[tipIds[0] - 1][1]
                : lmlist[tipIds[0]][1] < lmlist[tipIds[0] - 1][1];
            if (isThumbRaised) {
                fingerCount += 1;
            }

            // Check other fingers
            for (let i = 1; i < tipIds.length; i++) {
                const isFingerRaised = lmlist[tipIds[i]][2] < lmlist[tipIds[i] - 2][2];
                if (isFingerRaised) {
                    fingerCount += 1;
                }
            }

            return fingerCount;
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Crop and fit video to match canvas size without stretching
            const { drawWidth, drawHeight, offsetX, offsetY } = cropAndFitVideo(videoElement, canvasWidth, canvasHeight);
            canvasCtx.drawImage(results.image, offsetX, offsetY, drawWidth, drawHeight);

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    const lmlist = [];
                    for (let id = 0; id < 21; id++) {
                        const lm = landmarks[id];

                        // Adjust landmark positions according to the cropping and scaling of the video
                        let x = lm.x * drawWidth + offsetX;
                        let y = lm.y * drawHeight + offsetY;

                        lmlist.push([id, Math.round(x), Math.round(y)]);
                    }

                    if (lmlist.length === 21) {
                        const fingerCount = countFingers(lmlist);
                        fingerCountDisplay.innerText = `Fingers Raised: ${fingerCount}`;
                        console.log(fingerCount);
                    }

                    // Draw the landmarks and connections
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                    drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });
                }
            }

            canvasCtx.restore();
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.4
        });
        hands.onResults(onResults);

        let camera;

        function startCamera() {
            const constraints = {
                video: {
                    width: { ideal: canvasWidth },
                    height: { ideal: canvasHeight },
                    facingMode: 'user',
                    aspectRatio: canvasWidth / canvasHeight,
                }
            };

            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: canvasWidth,
                height: canvasHeight,
                facingMode: 'user',
                constraints: constraints.video
            });
            camera.start();
        }

        startCamera();
    </script>
</body>
</html>
